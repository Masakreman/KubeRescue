apiVersion: apps/v1
kind: Deployment
metadata:
  name: test3-service-cascade-app
  labels:
    app: test3-service-cascade-app
    test: "true"
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test3-service-cascade-app
  template:
    metadata:
      labels:
        app: test3-service-cascade-app
    spec:
      containers:
      - name: service-simulator
        image: python:3.9-slim
        command:
        - /bin/bash
        - -c
        - |
          cat > /app.py << 'EOF'
          import time
          import random
          import logging
          import json
          from datetime import datetime

          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
          logger = logging.getLogger()

          services = {
              "auth-service": {"status": "healthy", "dependencies": []},
              "database-service": {"status": "healthy", "dependencies": []},
              "cache-service": {"status": "healthy", "dependencies": ["database-service"]},
              "api-gateway": {"status": "healthy", "dependencies": ["auth-service", "cache-service"]},
              "frontend-service": {"status": "healthy", "dependencies": ["api-gateway"]}
          }

          def log_service_status():
              status_json = json.dumps({s: services[s]["status"] for s in services})
              logger.info(f"Services status: {status_json}")

          def check_dependencies(service_name):
              for dep in services[service_name]["dependencies"]:
                  if services[dep]["status"] != "healthy":
                      return False
              return True

          def heal_service(service_name):
              if random.random() < 0.7:
                  services[service_name]["status"] = "healthy"
                  logger.info(f"SERVICE_HEALED {service_name} recovered automatically")
                  return True
              return False

          def trigger_random_failure():
              failed_service = random.choice(list(services.keys()))
              services[failed_service]["status"] = "failed"
              
              if failed_service in ["auth-service", "database-service"]:
                  logger.error(f"CRITICAL_SERVICE_FAILURE {failed_service} is down, core functionality impacted")
              else:
                  logger.warning(f"SERVICE_DEGRADED {failed_service} is experiencing issues")
              
              for service, details in services.items():
                  if failed_service in details["dependencies"] and services[service]["status"] == "healthy":
                      services[service]["status"] = "degraded"
                      logger.warning(f"CASCADE_FAILURE {service} degraded due to dependency on {failed_service}")

          def check_system_health():
              failed = sum(1 for s in services.values() if s["status"] == "failed")
              degraded = sum(1 for s in services.values() if s["status"] == "degraded")
              
              if failed > 1 or (failed + degraded) > 3:
                  logger.error(f"SYSTEM_WIDE_FAILURE Multiple services affected ({failed} failed, {degraded} degraded)")
                  return False
              return True

          failure_countdown = random.randint(5, 15)
          healing_attempts = 0

          while True:
              log_service_status()
              
              failure_countdown -= 1
              
              for service_name in list(services.keys()):
                  if services[service_name]["status"] != "healthy":
                      if heal_service(service_name):
                          healing_attempts = 0
                      else:
                          healing_attempts += 1
              
              if healing_attempts > 5:
                  logger.error("PERSISTENT_SERVICE_FAILURE System unable to self-heal after multiple attempts")
                  healing_attempts = 0
              
              if failure_countdown <= 0:
                  trigger_random_failure()
                  check_system_health()
                  failure_countdown = random.randint(10, 30)
              
              time.sleep(3)
          EOF
          
          python /app.py